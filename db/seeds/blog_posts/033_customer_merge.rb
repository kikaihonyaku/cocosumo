# 記事33: 顧客統合（マージ）機能 — 「同じお客様が2人いる」問題を解決する
blog_post_33 = BlogPost.find_or_create_by!(public_id: 'customer-merge-2026') do |post|
  post.title = "顧客統合（マージ）機能を実装 — 複数チャネル時代の「同一人物」問題を安全に解決する"
  post.summary = "SUUMOからのメール反響とLINE友だち追加で同じお客様が2つのレコードに分かれてしまう問題を、スナップショット付きマージで安全に解決。3ステップのウィザードUI、自動重複検出、管理者による取り消し機能を実装しました。"
  post.content = <<~'MARKDOWN'
## はじめに — 「あれ、この方もう登録されてませんか？」

不動産CRMを使っていて、こんな経験はありませんか？

> 「SUUMOから問い合わせがあった田中さん、昨日LINE友だち追加してきた田中さんと同一人物みたいです」
> 「同じ電話番号なのに、別々の顧客として登録されています…」
> 「どっちの田中さんに対応履歴を書けばいいですか？」

不動産業界では、お客様が複数のチャネルからアプローチしてくるのは日常です。SUUMOからメールで反響、後日LINEで友だち追加、さらに電話で問い合わせ——同一人物なのに、システム上は別々の顧客レコードとして登録されてしまいます。

対応履歴が分散し、担当者は「この方、前にも問い合わせしていたのに気づかなかった」ということが起こりえます。今回、この問題を根本から解決する **顧客統合（マージ）機能** を実装しました。

## どんな機能？

### 3ステップの統合ウィザード

顧客詳細画面のヘッダーに追加された「統合」ボタンから、3ステップで顧客を統合できます。

**ステップ1: 統合先の選択**

名前・メール・電話番号でテナント内の顧客を検索し、統合したい相手を選びます。「プライマリ（残す方）」と「セカンダリ（吸収される方）」が明示され、入れ替えも可能です。

**ステップ2: フィールド解決**

両方の顧客情報をサイドバイサイドで比較し、どちらの値を採用するか選択します。

| フィールド | 動作 |
|-----------|------|
| 顧客名・電話番号 | どちらかを選択（片方だけ値がある場合は自動選択） |
| メールアドレス | 選択制。不採用側はメモに記録 |
| LINE ID | 選択制。**不採用側のLINE接続は切断される旨を警告** |
| メモ・要望 | 両方を自動結合 |
| 希望エリア | 両方の和集合 |
| ステータス | どちらかがアクティブならアクティブ |

**ステップ3: 確認と実行**

移動されるデータの件数（案件、対応履歴、顧客マイページなど）を確認し、任意で統合理由を入力して実行します。

### 自動重複検出

顧客詳細画面を開くと、バックグラウンドで重複候補が自動チェックされます。同じ電話番号の顧客が見つかった場合、画面上部にバナーで通知されます。

```
⚠ 重複の可能性がある顧客が 1件 あります
  田中太郎  📞 090-1234-5678  [信頼度 70%] [電話番号一致] [統合]
```

バナーの「統合」ボタンを押せば、そのまま統合ウィザードに進めます。

### 管理者向け統合履歴と取り消し

顧客一覧画面に「統合履歴」ボタンを追加しました。管理者はすべての統合履歴を確認でき、誤った統合を**取り消す**ことができます。

## 技術的なこだわり

### スナップショット付きマージ — 安全に、元に戻せるように

顧客統合で最も怖いのは「誤統合」です。完全マージ方式は既存クエリへの影響がゼロという大きなメリットがありますが、元に戻せないリスクがあります。

そこで今回採用したのが「**スナップショット付きマージ**」方式です。

```ruby
# CustomerMergeService#execute! — 統合の核心部分
ActiveRecord::Base.transaction do
  lock_customers!  # デッドロック防止のためID昇順でロック

  primary_snapshot = snapshot_customer(@primary)      # 統合前のプライマリを保存
  secondary_snapshot = build_secondary_snapshot        # セカンダリの全情報を保存

  apply_field_resolutions!    # フィールドの解決（どちらの値を採用するか）
  move_related_records!       # 案件・対応履歴・アクセス権をプライマリに移動

  CustomerMerge.create!(
    secondary_snapshot: secondary_snapshot,  # セカンダリの完全なスナップショット
    primary_snapshot: primary_snapshot,      # プライマリの統合前の状態
    # ...
  )

  @secondary.destroy!  # セカンダリを削除
end
```

`customer_merges` テーブルに保存されるスナップショットには、セカンダリの全カラム値に加え、移動された関連レコードのIDリストも含まれています。取り消し時にはこのスナップショットからセカンダリを復元し、関連レコードを元に戻します。

### レースコンディション対策

統合操作は、同一顧客への同時操作（メッセージ受信、別ユーザーによる編集など）と競合する可能性があります。PostgreSQLの行レベルロック `SELECT ... FOR UPDATE` で安全性を確保しています。

```ruby
def lock_customers!
  # デッドロック防止のため、必ずID昇順でロック
  ids = [@primary.id, @secondary.id].sort
  Customer.where(id: ids).order(:id).lock("FOR UPDATE").to_a
  @primary.reload
  @secondary.reload
end
```

2つの顧客を常にID昇順でロックすることで、複数の統合操作が同時に走ってもデッドロックが発生しません。

### 関連レコードの一括移動

パフォーマンスを考慮し、関連レコードの移動には `update_all` を使用しています。ActiveRecordのコールバックは呼ばれませんが、顧客IDの付け替えだけなので問題ありません。

```ruby
def move_related_records!
  Inquiry.where(customer_id: @secondary.id).update_all(customer_id: @primary.id)
  PropertyInquiry.where(customer_id: @secondary.id).update_all(customer_id: @primary.id)
  CustomerActivity.where(customer_id: @secondary.id).update_all(customer_id: @primary.id)
  CustomerAccess.where(customer_id: @secondary.id).update_all(customer_id: @primary.id)
  EmailDraft.where(customer_id: @secondary.id).update_all(customer_id: @primary.id)
end
```

これにより、既存の全クエリ（`where(customer_id:)` を使うもの）は一切変更不要です。リンク方式（両レコードを残してJOINで紐づける）と比較して、保守コストが圧倒的に低いのがこの方式のメリットです。

### 重複検出のアルゴリズム

`CustomerDuplicateDetector` は、電話番号と名前の組み合わせで重複を判定します。

```ruby
class CustomerDuplicateDetector
  PHONE_MATCH_CONFIDENCE = 70          # 電話番号一致
  PHONE_AND_NAME_MATCH_CONFIDENCE = 90 # 電話番号 + 名前一致
  NAME_ONLY_MATCH_CONFIDENCE = 50      # 名前のみ一致
end
```

同一メールアドレスやLINE IDはユニーク制約があるため、そもそも重複レコードは作られません。重複が発生するのは「メール反響の田中さん」と「電話問い合わせの田中さん」のように、異なる識別子で登録されたケースです。電話番号はハイフンやスペースを正規化してから比較しています。

## 実際の使われ方

### ケース1: SUUMO反響 → LINE友だち追加

SUUMOからメールで問い合わせがあった田中さんが、翌日にLINEで友だち追加。メールアドレスとLINE IDが別々のレコードに。電話番号が同じなら自動検出され、バナーで通知されます。

### ケース2: ポータル違いの問い合わせ

SUUMOとat homeで異なるメールアドレスで問い合わせ。名前と電話番号が一致する場合に検出。統合時には「どちらのメールアドレスを残すか」を選択し、不採用のアドレスはメモに自動記録されます。

### ケース3: スタッフの手動登録ミス

電話問い合わせを受けたスタッフが、既存顧客と知らずに新規登録。同一電話番号＋同一名前で信頼度90%として検出されるので、すぐに統合できます。

### ケース4: 誤統合の取り消し

「山田さんと山田さんを統合したけど、実は別人だった！」——管理者が統合履歴から「取消」ボタンを押すだけで、セカンダリが復元され、移動されたデータも元に戻ります。

## まとめ

顧客統合機能は、**マルチチャネル時代の不動産CRMに不可欠な機能**です。

今回の実装で重視したのは以下の3点です。

1. **安全性** — スナップショット保存による取り消し可能な設計
2. **既存コードへの影響ゼロ** — 完全マージ方式により、全クエリが変更不要
3. **使いやすさ** — 自動重複検出 + 3ステップウィザード + バナー通知

「あの顧客レコード、どっちが本物？」と悩む時間がなくなり、すべての対応履歴が1つの顧客に集約される——それだけで、お客様への対応品質は確実に上がります。

今後は、新規顧客登録時の自動検出をさらに強化し、登録の段階で「既存の顧客と統合しますか？」と提案する仕組みも検討しています。
  MARKDOWN
  post.status = :published
  post.published_at = Time.zone.parse('2026-02-14 12:00:00')
  post.commit_hash = 'b4ad443'
end

puts "✓ 記事作成: #{blog_post_33.title}"
